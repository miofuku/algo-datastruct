[
    {
      "question": "什么是算法的时间复杂度?",
      "answer": "算法的时间复杂度是用来衡量算法运行时间随输入规模增长的变化趋势。它通常用大O符号表示,例如O(n)表示线性时间复杂度,O(log n)表示对数时间复杂度,O(n^2)表示平方时间复杂度等。时间复杂度帮助我们比较不同算法的效率,特别是在处理大规模数据时。"
    },
    {
      "question": "什么是递归?请给出一个例子。",
      "answer": "递归是一种解决问题的方法,其中函数调用自身来解决更小规模的相同问题,直到达到一个基本情况。一个经典的递归例子是计算斐波那契数列:\n\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\n这个函数通过调用自身来计算较小的斐波那契数,直到达到基本情况(n <= 1)。"
    },
    {
      "question": "什么是栈(Stack)数据结构?它的主要操作是什么?",
      "answer": "栈是一种遵循后进先出(LIFO)原则的线性数据结构。想象一堆叠放的盘子,你只能从顶部添加或移除盘子。栈的主要操作包括:\n1. push: 将元素添加到栈顶\n2. pop: 移除并返回栈顶元素\n3. peek或top: 返回栈顶元素但不移除\n4. isEmpty: 检查栈是否为空\n\n栈常用于函数调用、表达式求值、括号匹配等场景。"
    },
    {
      "question": "什么是快速排序(Quick Sort)算法?它的平均时间复杂度是多少?",
      "answer": "快速排序是一种高效的分治排序算法。其基本步骤是:\n1. 选择一个 '基准' 元素\n2. 将数组分区,使得小于基准的元素在左边,大于基准的元素在右边\n3. 递归地对左右两个子数组进行快速排序\n\n快速排序的平均时间复杂度是O(n log n),这使它成为实践中最常用的排序算法之一。然而,在最坏情况下(例如,当数组已经排序时),其时间复杂度可能退化到O(n^2)。"
    },
    {
      "question": "什么是哈希表(Hash Table)?它的主要优势是什么?",
      "answer": "哈希表是一种基于键值对存储的数据结构,它使用哈希函数将键映射到存储桶或槽位,从而实现高效的数据检索。哈希表的主要优势包括:\n1. 快速查找: 平均情况下,查找、插入和删除操作的时间复杂度都是O(1)\n2. 灵活性: 可以存储各种类型的键值对\n3. 空间效率: 相比于某些树结构,哈希表通常更节省空间\n\n哈希表广泛应用于数据库索引、缓存系统、符号表等场景。然而,需要注意处理哈希冲突,并在必要时进行rehash操作。"
    },
    {
      "question": "什么是动态规划(Dynamic Programming)?它适用于哪类问题?",
      "answer": "动态规划是一种通过将复杂问题分解为更简单的子问题来解决优化问题的方法。它的核心思想是存储和重用子问题的解,以避免重复计算。动态规划适用于具有以下特征的问题:\n1. 最优子结构: 问题的最优解包含子问题的最优解\n2. 重叠子问题: 子问题会被重复计算多次\n\n动态规划常用于解决如下类型的问题:\n- 最短路径问题\n- 背包问题\n- 序列对齐\n- 最长公共子序列\n- 矩阵链乘法\n\n使用动态规划可以显著提高某些问题的求解效率,将指数级时间复杂度降低到多项式级。"
    },
    {
      "question": "什么是广度优先搜索(BFS)和深度优先搜索(DFS)?它们的主要区别是什么?",
      "answer": "广度优先搜索(BFS)和深度优先搜索(DFS)都是图遍历算法:\n\nBFS:\n- 从起始节点开始,先访问所有相邻节点,然后再访问下一层节点\n- 使用队列数据结构\n- 适合寻找最短路径或最少步骤的解\n\nDFS:\n- 从起始节点开始,尽可能深入图的分支,直到达到叶子节点才回溯\n- 使用栈数据结构(或递归实现)\n- 适合探索图的所有可能路径或检查图的连通性\n\n主要区别:\n1. 搜索顺序: BFS按层次搜索,DFS按深度搜索\n2. 内存使用: BFS可能需要存储整个层的节点,而DFS只需要存储当前路径\n3. 完整性: 在无限图中,BFS总能找到最短路径,而DFS可能陷入无限循环\n4. 应用场景: BFS常用于最短路径问题,DFS常用于遍历所有可能性"
    },
    {
      "question": "什么是平衡二叉搜索树?为什么它们很重要?",
      "answer": "平衡二叉搜索树是一种特殊的二叉搜索树,它通过保持树的平衡来确保基本操作(如插入、删除和查找)的时间复杂度保持在O(log n)。\n\n常见的平衡二叉搜索树包括:\n- AVL树\n- 红黑树\n- B树和B+树\n\n平衡二叉搜索树的重要性:\n1. 效率: 保证了查找、插入和删除操作的对数时间复杂度\n2. 可预测性: 操作时间复杂度的上界是固定的,不会因为特定的数据分布而退化\n3. 广泛应用: 用于实现数据库索引、文件系统等\n4. 自平衡: 在插入和删除操作后自动调整以保持平衡\n\n相比普通的二叉搜索树,平衡树避免了在某些情况下(如顺序插入)导致的性能退化,确保了稳定的性能。"
    },
    {
      "question": "什么是贪心算法?它的优点和局限性是什么?",
      "answer": "贪心算法是一种在每一步选择中都采取在当前状态下最好或最优(即最有利)的选择,从而希望导致结果是最好或最优的算法。\n\n优点:\n1. 简单高效: 通常实现简单,运行速度快\n2. 局部最优: 在每一步都能得到局部最优解\n3. 适用性广: 可以解决许多实际问题\n\n局限性:\n1. 不保证全局最优: 局部最优不一定导致全局最优\n2. 适用范围有限: 不是所有问题都能用贪心算法解决\n3. 需要证明: 使用贪心算法时,通常需要证明其正确性\n\n贪心算法常用于解决如下问题:\n- 活动选择问题\n- Huffman编码\n- 最小生成树(Kruskal和Prim算法)\n- 某些调度问题\n\n在使用贪心算法时,需要仔细考虑问题的性质,确保贪心策略能够得到全局最优解。"
    }
  ]